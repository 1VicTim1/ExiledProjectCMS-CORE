# Docker Compose for Distributed Deployment
# Use this configuration to deploy services across multiple machines

version: '3.8'

services:
  # Main C# API - can be deployed on multiple machines
  cms-api:
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=${ENVIRONMENT:-Production}
      - ASPNETCORE_URLS=http://+:80
      - DatabaseProvider=${DATABASE_PROVIDER:-SqlServer}
      - CacheProvider=${CACHE_PROVIDER:-Redis}
      - ConnectionStrings__DefaultConnection=${DB_CONNECTION_STRING}
      - ConnectionStrings__Redis=${REDIS_HOST:-redis}:${REDIS_PORT:-6379},password=${REDIS_PASSWORD}
      - Admin__DefaultUsername=${ADMIN_USERNAME:-admin}
      - Plugins__Directory=/app/Plugins
    ports:
      - "${API_PORT:-5006}:80"
    volumes:
      - ${SHARED_STORAGE:-./shared}/Plugins:/app/Plugins
      - ${SHARED_STORAGE:-./shared}/Uploads:/app/Uploads
      - ./logs:/app/Logs
    networks:
      - exiled-distributed
    deploy:
      replicas: ${API_REPLICAS:-2}
      placement:
        constraints:
          - node.labels.type == api
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  # High-Performance Go API - can be deployed on multiple machines
  go-api:
    build:
      context: ./GoServices/HighPerformanceAPI
      dockerfile: Dockerfile
    environment:
      - GO_API_PORT=8080
      - DATABASE_PROVIDER=${DATABASE_PROVIDER:-postgres}
      - DATABASE_URL=${GO_DB_CONNECTION_STRING}
      - REDIS_URL=${REDIS_HOST:-redis}:${REDIS_PORT:-6379}
      - MAIN_API_URL=${MAIN_API_URL:-http://cms-api:80}
      - ENVIRONMENT=${ENVIRONMENT:-production}
    ports:
      - "${GO_API_PORT:-8080}:8080"
    networks:
      - exiled-distributed
    deploy:
      replicas: ${GO_API_REPLICAS:-3}
      placement:
        constraints:
          - node.labels.type == compute
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  # Admin Panel - can be deployed on multiple machines
  admin-panel:
    build:
      context: ./Frontend/admin-panel
      dockerfile: Dockerfile
    environment:
      - NODE_ENV=production
      - VITE_API_BASE_URL=${API_BASE_URL:-http://cms-api:80}
    ports:
      - "${ADMIN_PORT:-3000}:80"
    networks:
      - exiled-distributed
    deploy:
      replicas: ${ADMIN_REPLICAS:-1}
      placement:
        constraints:
          - node.labels.type == frontend
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M

  # Public Website - can be deployed on multiple machines
  webapp:
    build:
      context: ./Frontend/webapp
      dockerfile: Dockerfile
    environment:
      - NODE_ENV=production
      - VITE_API_BASE_URL=${API_BASE_URL:-http://cms-api:80}
      - VITE_GO_API_BASE_URL=${GO_API_BASE_URL:-http://go-api:8080}
    ports:
      - "${WEBAPP_PORT:-8090}:80"
    networks:
      - exiled-distributed
    deploy:
      replicas: ${WEBAPP_REPLICAS:-3}
      placement:
        constraints:
          - node.labels.type == frontend
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M

  # Load Balancer - typically deployed on edge nodes
  nginx:
    image: nginx:alpine
    ports:
      - "${HTTP_PORT:-80}:80"
      - "${HTTPS_PORT:-443}:443"
    volumes:
      - ./nginx/distributed.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ${SSL_CERTS_PATH:-./ssl}:/etc/nginx/ssl:ro
    networks:
      - exiled-distributed
    deploy:
      replicas: ${LB_REPLICAS:-2}
      placement:
        constraints:
          - node.labels.type == loadbalancer
      resources:
        limits:
          memory: 128M
        reservations:
          memory: 64M
      restart_policy:
        condition: on-failure

networks:
  exiled-distributed:
    external: true
    attachable: true

# Volumes for shared storage (NFS/GlusterFS/Ceph)
volumes:
  shared-plugins:
    driver_opts:
      type: nfs
      o: addr=${NFS_SERVER},rw
      device: ":${NFS_PLUGINS_PATH}"

  shared-uploads:
    driver_opts:
      type: nfs
      o: addr=${NFS_SERVER},rw
      device: ":${NFS_UPLOADS_PATH}"

  shared-logs:
    driver_opts:
      type: nfs
      o: addr=${NFS_SERVER},rw
      device: ":${NFS_LOGS_PATH}"